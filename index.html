<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Vizer Prototype</title>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
 <style>
      body {
        margin: 0px;
        overflow: hidden;
      }
      #example {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }
    </style> 
  </head>
  <body>
    <div id="example"></div>


  <script src="js/third-party/threejs/three.js"></script>
  <script src="js/third-party/threejs/StereoEffect.js"></script>
  <script src="js/third-party/threejs/DeviceOrientationControls.js"></script>
  <script src="js/third-party/threejs/OrbitControls.js"></script>
  <script src="js/third-party/threejs/Detector.js"></script> 
  <script src="js/third-party/threejs/RoomObjs.js"></script>  

  <script>
    var camera, scene, renderer;
    var effect, controls;
    var element, container;
    var sphere;
    var selectedLink = null;
    var currentRoom = null;
    var magnificationFactor = 1.4;
    var rooms = [];
    var texloader;

    var clock = new THREE.Clock();

    setupRooms();
    init();
    setScene(rooms[9]);
    animate();

    function setupRooms(){
      // var r0 = new Room(0, "photosphere.jpg");
      // r0.links.push(new RoomLink(1,0,0));
      // r0.links.push(new RoomLink(1,50,0));
      // r0.links.push(new RoomLink(1,100,0));
      // r0.links.push(new RoomLink(1,170.53,16.64));
      // // r0.links.push(new RoomLink(1,20,0));
      // // r0.links.push(new RoomLink(1,20,0));
      // rooms.push(r0);

      // var r1 = new Room(1, "photosphere2.jpg");
      // r1.links.push(new RoomLink(0,0,0));
      // rooms.push(r1);

      /********* BASEMENT *********/
      // var r0 = new Room(0, "images/basement0.JPG");
      // r0.links.push(new RoomLink(1,90.14,-5.48));
      // r0.links.push(new RoomLink(2,62.68,-2.17));
      // rooms.push(r0);

      // var r1 = new Room(1, "images/basement1.JPG");
      // r1.links.push(new RoomLink(0,85.23,-173.37));
      // r1.links.push(new RoomLink(2,45.56,-5.67));
      // rooms.push(r1);

      // var r2 = new Room(2, "images/basement2.JPG");
      // r2.links.push(new RoomLink(0,107.77,-176.68));
      // r2.links.push(new RoomLink(1,135.04,-171.69));
      // r2.links.push(new RoomLink(3,18.73,-152.78));
      // rooms.push(r2);

      // var r3 = new Room(3, "images/basement3.JPG");
      // r3.links.push(new RoomLink(2,153.47,-9.84));
      // rooms.push(r3);

      /********* HOUSE *********/
      var r0 = new Room(0, "images/foyer.JPG");
      r0.links.push(new RoomLink(1,165.65,-141.73));
      r0.links.push(new RoomLink(7,28.24,-170.39));
      r0.links.push(new RoomLink(8,85.04,138.92));
      r0.links.push(new RoomLink(5,100.12,-6.263));

      rooms.push(r0);

      var r1 = new Room(1, "images/diningarea.JPG");
      r1.links.push(new RoomLink(0,16.72,-35.95));
      r1.links.push(new RoomLink(2,73.83,179.81));
      r1.links.push(new RoomLink(7,15.78,-172.19));
      rooms.push(r1);

      var r2 = new Room(2, "images/kitchen.JPG");
      r2.links.push(new RoomLink(1,105.81,-6.07));
      r2.links.push(new RoomLink(4,81.215,-178.21));
      r2.links.push(new RoomLink(3,17.33,-37.18));
      rooms.push(r2);

      var r3 = new Room(3, "images/livingroom.JPG");
      r3.links.push(new RoomLink(2,163.71,-177.65));
      r3.links.push(new RoomLink(7,90.89,-8.67));
      r3.links.push(new RoomLink(4,90.57,-178.83));
      rooms.push(r3);

      var r4 = new Room(4, "images/backyard.JPG");
      r4.links.push(new RoomLink(2,95.32,4.83));
      r4.links.push(new RoomLink(3,75.79, 4.76));
      rooms.push(r4);

      var r5 = new Room(5, "images/frontdoor.JPG");
      r5.links.push(new RoomLink(0,85.41,174.68));
      r5.links.push(new RoomLink(9,72.07,-1.74));
      rooms.push(r5);

      var r6 = new Room(6, "images/bathroom.JPG");
      r6.links.push(new RoomLink(7,174.51,-103.87));
      rooms.push(r6);

      var r7 = new Room(7, "images/hallway.JPG");
      r7.links.push(new RoomLink(6,3.22,-81.46));
      r7.links.push(new RoomLink(0,151.39,-7.97));
      r7.links.push(new RoomLink(3,90.71,-175.89));
      rooms.push(r7);

      var r8 = new Room(8, "images/secondfloor.JPG");
      r8.links.push(new RoomLink(0,102.08,-37.81));
      rooms.push(r8); 

      var r9 = new Room(9, "images/outsidehouse.JPG");
      r9.links.push(new RoomLink(5,109.65,175.75));
      r9.featureBubbles.push(new FeatureBubble(1,85.41,174.68, 'Here Lies Shrek the conqueror of worlds, no one dares to face him because he is shrek'));
      rooms.push(r9); 
    }

    function setScene(room){
      currentRoom = room;

      var tex = texloader.load(room.image);

      sphere = new THREE.Mesh(
        new THREE.SphereGeometry(100, 60, 60),
        new THREE.MeshBasicMaterial({
        map: tex
      })
      );
      /* Why are we applying a linear filter? do texels not map directly to pixels? */
      sphere.material.map.minFilter = THREE.LinearFilter;
      
      sphere.scale.x = -1;
      scene.add(sphere);

      addLinksToScene(room);
      addFeatureBubblesToScene(room);
    }

    function addLinksToScene(room)
    {
      for(i = 0; i < room.links.length; i++)
      {
        if(room.links[i].linkSprite == null)
        {
          var texture = new THREE.Texture( generateLinkSprite() );
          texture.needsUpdate = true; // important!
          /* Why is this important*/

          /* Can you apply a texture as a texure map itself?*/
          var material = new THREE.SpriteMaterial( { map: texture } );

          room.links[i].linkSprite = new THREE.Sprite( material );
          /* Why scale the sprite link here when you can just increase the size of the canvas */
          room.links[i].linkSprite.scale.set(10,10,10);

        }

        var distRadius = 90;
        var theta = toRadians(room.links[i].theta);
        var phi = toRadians(room.links[i].phi);

        var cartesianPosition = sphericalToCartesian(distRadius, theta,phi);

        room.links[i].linkSprite.position.set(cartesianPosition.x,cartesianPosition.y,cartesianPosition.z);
        scene.add(room.links[i].linkSprite);

      }
    }

    function addFeatureBubblesToScene(room)
    {
      for(i = 0; i < room.featureBubbles.length; i++)
      {
        if(room.featureBubbles[i].backgroundSprite == null)
        {
          var texture = new THREE.Texture( generateFeatureBubbleBackground(room.featureBubbles[i].informationText) );
          texture.needsUpdate = true; // important!
          /* Why is this important*/

          /* Can you apply a texture as a texure map itself?*/
          var material = new THREE.SpriteMaterial( { map: texture } );

          room.featureBubbles[i].backgroundSprite = new THREE.Sprite( material );
          /* Why scale the sprite link here when you can just increase the size of the canvas */
          console.log("scale x: " + room.featureBubbles[i].backgroundSprite.scale.x + " scale y: " + room.featureBubbles[i].backgroundSprite.scale.y + " scale z: " + room.featureBubbles[i].backgroundSprite.scale.z);
          room.featureBubbles[i].backgroundSprite.scale.set(30,30,30);
           console.log("scale x after: " + room.featureBubbles[i].backgroundSprite.scale.x + " scale y after: " + room.featureBubbles[i].backgroundSprite.scale.y + " scale z after: " + room.featureBubbles[i].backgroundSprite.scale.z);
        }

        var distRadius = 40;
        var theta = toRadians(room.featureBubbles[i].theta);
        var phi = toRadians(room.featureBubbles[i].phi);

        var cartesianPosition = sphericalToCartesian(distRadius, theta,phi);

        room.featureBubbles[i].backgroundSprite.position.set(cartesianPosition.x,cartesianPosition.y,cartesianPosition.z);
        scene.add(room.featureBubbles[i].backgroundSprite);
      }
    }

    function generateLinkSprite()
    {
      var canvas = document.createElement( 'canvas' );
      canvas.width = 256;
      canvas.height = 256;

      var context = canvas.getContext( '2d' );

      var centerX = canvas.width / 2;
      var centerY = canvas.height / 2;
      var radius = 50;

      context.beginPath();
      context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
      context.fillStyle = '#F0C400';
      context.fill();
      context.lineWidth = 10;
      context.strokeStyle = '#000000'; 
      context.stroke();

      return canvas; 
    }

    function generateFeatureBubbleBackground(featureText)
    {
      var canvas = document.createElement( 'canvas' );
      canvas.width = 512;
      canvas.height = 512;

      var context = canvas.getContext( '2d' );

      var textSize = 16;
      var font = textSize + "px Arial";
      context.fillStyle = '#000000';
      context.font = font;
      // drawTextBG(context, "loco", font, 30,30 )

      var numberOfLines = NumberOfLines(context, featureText, 100, 100, canvas.width - 50, textSize + 5);
      var textWidth = context.measureText(featureText).width; 
      if (numberOfLines > 1) 
      {
        textWidth = canvas.width;
      };

      textHeight = (textSize + 5) * numberOfLines;

      // console.log("number of lines: " + numberOfLines);    
      console.log("text width: " + textWidth);

      // function roundRect(ctx, x, y, w, h, r)    

      roundRect(context,80, 80, textWidth + 50, textHeight + 20, 45.0);
      // context.fillStyle = '#f50';  
      // context.fillRect(100, 100, textWidth, textHeight);
      // context.stroke();
      context.beginPath();
      context.font = font;
      context.fillStyle = '#000000';
      wrapText(context, featureText, 100, 100, canvas.width, textSize + 5);

      return canvas;
    }

    function drawTextBG(ctx, txt, font, x, y) {

    /// lets save current state as we make a lot of changes        
    ctx.save();

    /// set font
    ctx.font = font;

    /// draw text from top - makes life easier at the moment
    ctx.textBaseline = 'top';

    /// color for background
    ctx.fillStyle = '#f50';

    /// get width of text
    var width = ctx.measureText(txt).width;

    /// draw background rect assuming height of font
    ctx.fillRect(x, y, width, parseInt(font, 10));

    /// text color
    ctx.fillStyle = '#000';

    /// draw text on top
    ctx.fillText(txt, x, y);

    /// restore original state
    ctx.restore();
}

    function sphericalToCartesian(radius, theta, phi)
    {
      var xPos = radius * Math.sin(theta) * Math.cos(phi);
      var yPos = radius * Math.sin(theta) * Math.sin(phi);
      var zPos = radius * Math.cos(theta);

      return new THREE.Vector3(xPos,yPos,zPos);
    }

   function keyDownEvent(event)
    {
      window.onkeyup = function(e) {
        var key = e.keyCode ? e.keyCode : e.which;
        console.log(key);

        if(key == 38)
        {
          camera.translateZ( 5 );
        }
        else if(key == 40)
        {
          camera.translateZ( -5 );
        }
      }
    }

    function init() {

      renderer = new THREE.WebGLRenderer({ antialiasing: true });
      renderer.setPixelRatio(window.devicePixelRatio);

      window.onkeydown = keyDownEvent;

      element = renderer.domElement;
      container = document.getElementById('example');
      container.appendChild(element);

      effect = new THREE.StereoEffect(renderer);
      effect.setSize( window.innerWidth, window.innerHeight );
      effect.separation = -9;

      scene = new THREE.Scene();

      texloader = new THREE.TextureLoader();

      camera = new THREE.PerspectiveCamera(90, 1, 0.001, 700);
      camera.position.set(0, 0, 0);
      camera.fov = 90;
      scene.add(camera);

      controls = new THREE.OrbitControls(camera, element);
      // controls.rotateUp(Math.PI / 4);
      controls.target.set(
        camera.position.x - 0.1,
        camera.position.y,
        camera.position.z 
      );
      controls.noZoom = true;
      controls.noPan = true;

      element.addEventListener('click', clickEvent, false);

      function setOrientationControls(e) {
        if (!e.alpha) {
          return;
        }

        controls = new THREE.DeviceOrientationControls(camera, true);
        controls.connect();
        controls.update();

        element.addEventListener('click', clickEvent, false);

        window.removeEventListener('deviceorientation', setOrientationControls, true);
      }

      window.addEventListener('deviceorientation', setOrientationControls, true);

      window.addEventListener('resize', resize, false);
      setTimeout(resize, 1);
    }

    function toRadians (angle) {
      return angle * (Math.PI / 180);
    }

    function resize() {
      var width = container.offsetWidth;
      var height = container.offsetHeight;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();

      renderer.setSize(width, height);
      // effect.setSize(width, height);
      effect.setSize( window.innerWidth, window.innerHeight );
    }

    function update(dt) {
      resize();

      camera.updateProjectionMatrix();

      controls.update(dt);
    }

    function render(dt) {
      // renderer.render(scene,camera);
      effect.render(scene, camera);
    }

    function animate(t) {
      requestAnimationFrame(animate);

      highlightLinks();

      update(clock.getDelta());
      render(clock.getDelta());
    }

    function highlightLinks()
    {
      var closestLink = null;
      var closestLinkDotP = 0;

      var cameraLookatVec = new THREE.Vector3( 0, 0, -1 );
      cameraLookatVec.applyQuaternion( camera.quaternion );
      cameraLookatVec.normalize();

      if(currentRoom == null)
        return;

      for(i = 0; i  < currentRoom.links.length; i++)
      {
        var circlePos = currentRoom.links[i].linkSprite.position.clone();
        circlePos.normalize();

        var dotP = cameraLookatVec.dot(circlePos);

        if(dotP > closestLinkDotP)
        {
          closestLinkDotP = dotP;
          closestLink = currentRoom.links[i];
        }
      }

      if(closestLinkDotP < 0.95)
      {
        dehighlightLinkSprite(selectedLink);
        selectedLink = null;
      }
      else if(closestLink != selectedLink)
      {
        dehighlightLinkSprite(selectedLink);
        selectedLink = closestLink;
        highlightLinkSprite(selectedLink);
      }

    }

    function highlightLinkSprite(link)
    {
      if(link != null){
        link.linkSprite.scale.set(20,20,20);
      }
    }

    function dehighlightLinkSprite(link)
    {
      if(link != null){
        link.linkSprite.scale.set(10,10,10);
      }
    }

    function highlightCircleMesh(link)
    {
      if(link != null){
        link.circleMesh.material = new THREE.MeshBasicMaterial( { color: 0xF0C400, side: THREE.DoubleSide } );
        link.circleMesh.scale.set(magnificationFactor, magnificationFactor, magnificationFactor);
      }
    }
      
    function dehighlightCircleMesh(link)
    {
      if(link != null){
        link.circleMesh.material = new THREE.MeshBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
        link.circleMesh.scale.set(1/magnificationFactor, 1/magnificationFactor, 1/magnificationFactor);
      }
    }

    function fullscreen() {
      if (container.requestFullscreen) {
        container.requestFullscreen();
      } else if (container.msRequestFullscreen) {
        container.msRequestFullscreen();
      } else if (container.mozRequestFullScreen) {
        container.mozRequestFullScreen();
      } else if (container.webkitRequestFullscreen) {
        container.webkitRequestFullscreen();
      }
    }

    function clickEvent()
    {

      if(selectedLink != null)
      {
        dehighlightLinkSprite(selectedLink);
        // clearScene();
        // currentRoom = null;
        // setScene(rooms[selectedLink.toId]);
        switchRooms(rooms[selectedLink.toId]);
        selectedLink = null;
      }
        // effect.separation = effect.separation + 1;
    }

    function switchRooms(newRoom)
    {
      //remove old links
      for(i = 0; i < currentRoom.links.length; i++)
      { 
        scene.remove(currentRoom.links[i].linkSprite);
        currentRoom.links[i].linkSprite.geometry.dispose();  
        currentRoom.links[i].linkSprite.material.map.dispose();
        currentRoom.links[i].linkSprite.material.dispose();  
      }

      sphere.material.map.dispose();
      var tex = texloader.load(newRoom.image);
      sphere.material.map = tex;
      sphere.material.map.minFilter = THREE.LinearFilter;

      addLinksToScene(newRoom);

      currentRoom = newRoom;
    }

    function clearScene()
    {
      scene.remove(sphere);
      sphere.material.map.dispose();
      sphere.material.dispose();
      sphere.geometry.dispose();

      for(i = 0; i < currentRoom.links.length; i++)
      { 
        scene.remove(currentRoom.links[i].linkSprite);
        currentRoom.links[i].linkSprite.geometry.dispose();  
        currentRoom.links[i].linkSprite.material.map.dispose();
        currentRoom.links[i].linkSprite.material.dispose();  
      }
    }

    function makeTextSprite( message, parameters )
    {
        if ( parameters === undefined ) parameters = {};
        var fontface = parameters.hasOwnProperty("fontface") ? parameters["fontface"] : "Arial";
        var fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 18;
        var borderThickness = parameters.hasOwnProperty("borderThickness") ? parameters["borderThickness"] : 4;
        var borderColor = parameters.hasOwnProperty("borderColor") ?parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };
        var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };
        var textColor = parameters.hasOwnProperty("textColor") ?parameters["textColor"] : { r:0, g:0, b:0, a:1.0 };

        var canvas = document.createElement('canvas');
        var context = canvas.getContext('2d');
        context.font = "Bold " + fontsize + "px " + fontface;
        var metrics = context.measureText( message );
        var textWidth = metrics.width;

        context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
        context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," + borderColor.a + ")";

        context.lineWidth = borderThickness;
        roundRect(context, borderThickness/2, borderThickness/2, (textWidth + borderThickness) * 1.1, fontsize * 1.4 + borderThickness, 8);

        context.fillStyle = "rgba("+textColor.r+", "+textColor.g+", "+textColor.b+", 1.0)";
        context.fillText( message, borderThickness, fontsize + borderThickness);

        var texture = new THREE.Texture(canvas) 
        texture.needsUpdate = true;

        var spriteMaterial = new THREE.SpriteMaterial( { map: texture, useScreenCoordinates: false } );
        var sprite = new THREE.Sprite( spriteMaterial );
        sprite.scale.set(0.5 * fontsize, 0.25 * fontsize, 0.75 * fontsize);
        return sprite;  
    }

    function roundRect(ctx, x, y, w, h, r) { 
      ctx.beginPath(); ctx.moveTo(x + r, y); 
      ctx.lineTo(x + w - r, y); 
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r); ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.fillStyle = "rgba(127, 255, 0, 0.5)";
      ctx.fill();
      ctx.lineWidth = 2.5;
      ctx.strokeStyle = '#000000'; 
      ctx.closePath(); ctx.fill(); ctx.stroke(); 
    }

    function wrapText(context, text, x, y, maxWidth, lineHeight) 
    {
        var words = text.split(' ');
        var line = '';

        for(var n = 0; n < words.length; n++) 
        {
          var testLine = line + words[n] + ' ';
          var metrics = context.measureText(testLine);
          var testWidth = metrics.width;

          if (testWidth > maxWidth && n > 0) 
          {
            context.fillText(line, x, y);
            line = words[n] + ' ';
            y += lineHeight;
          }
          else 
          {
            line = testLine;
          }
        }
        context.fillText(line, x, y);
    }


    function NumberOfLines(context, text, x, y, maxWidth, lineHeight) 
    {
        var words = text.split(' ');
        var line = '';
        var numberoflines = 1;

        for(var n = 0; n < words.length; n++) 
        {
          var testLine = line + words[n] + ' ';
          var metrics = context.measureText(testLine);
          var testWidth = metrics.width;

          if (testWidth > maxWidth && n > 0) 
          {
            line = words[n] + ' ';
            y += lineHeight;
            numberoflines = numberoflines + 1;
          }
          else 
          {
            line = testLine;
          }
        }

        return numberoflines;
    }
  </script>
  </body>
</html>
